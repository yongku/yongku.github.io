<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="format-detection" content="telephone=no, address=no, email=no, date=no">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>06 jvascript - 배열(Array), 함수(Function))</title>
	<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
	<link rel="stylesheet" type="text/css" href="css/reset.css">
	<script type="text/javascript" src="js/jquery/jquery-1.12.4.min.js"></script>
	<script type="text/javascript" src="js/jquery/jquery.easing.min.js"></script>
	<style>
		.jqbox{
			width:400px;
			margin:0 auto;
			padding:20px;
			border:2px solid #000;
			text-align:center;
		}
		.jqbox button{
			width:45%;
			padding:10px;
			border:1px solid #000;
		}
		.jqbox section{
			padding:10px;
			border:1px solid blue;
		}
		a::after{
			content:attr(color);
		}
	</style>
</head>
<body>
	<a href="https://www.naver.com" color="#f00"></a>
	<div class="jqbox">
		<script>
			/********* 자바스크립트 방법 *********/
			function scriptClick(){
				document.getElementById("scriptSection").innerHTML="안녕하세요! 자바스크립트로 변경이 되었네요";
			}
			
			/********* 제이쿼리 방법 *********/
			$(document).ready(function(){
				$('#jqClick').click(function(){
					$("#jqSection").text("안녕하세요! 제이쿼리로 변경되었네요");
				})
			});
		</script>
			
		<button id="jqClick">클릭하세요</button> <button onclick="scriptClick()">클릭하세요</button>
		<section id="jqSection">
			<p>현재 자바스크립트를 공부하고 있습니다.</p>
		</section>
		<section id="scriptSection">
			<p>현재 자바스크립트를 공부하고 있습니다.</p>
		</section>
	</div>
<!--

================= 변수 복습 ===============================================================================================
var scope = 'global(전역변수)'; 
function fnScope() { 
	console.log(scope); 
} 
fnScope();
위 코드의 취지는 함수 안에 선언되어 있지 않고 함수 밖에 선언되어 있는 scope 라는 변수에 접근할 수 있다라는 것이 포인트입니다. 
함수 밖에서 변수를 선언하면 그 변수는 전역변수가 되고 전역변수는 애플리케이션 전역에서 접근이 가능한 변수입니다.
다시 말해서, 어떤 함수 안에서도 그 변수에 접근 할 수가 있다. 
그렇기 때문에 fnScope 내에서 scope를 호츨했을 때 함수 밖에서 선언된 scope의 값인 global이 반환된 것입니다.

var scope = 'global(전역변수)'; 
function fnScope() { 
	var scope = 'local(지역변수)'; 
	console.log('함수안 '+scope); 
} 
fnScope(); 
console.log('함수밖 ' + scope);
위 코드는 함수 안에서 scope를 조회 했을때 함수 내에서 선언한 지역변수인 local이 사용되었습니다.
하지만 함수 밖에서 scope를 호출했을때는 전역변수인 global이 사용된 것입니다.
이렇게 지역변수의 유효범위는 함수 안이고, 
전역 변수 유효범위는 애플리케이션 전역인데, 
같은 이름의 지역변수와 전역 변수가 동시에 정의되어 있다면 지역변수가 우선한다는 것을 알수 있습니다.

var scope = 'global(전역변수)'; 
function fnScope() { 
	scope = 'local(지역변수)'; 
	console.log('함수안 '+scope); 
} 
fnScope(); 
console.log('함수밖 ' + scope);

함수밖에서도 scope의 값이 local인 이유는 무엇일까? 
그것은 함수 fnScope의 지역변수를 선언할 때 var를 사용하지않았기 때문입니다. 
var를 사용하지 않은 변수는 전역변수가 됩니다. 
따라서 전역변수의 값을 local로 변경하게 된 것이다.

그렇기 때문에 var를 쓰는 것과 쓰지 않는 것의 차이를 이해해야 합니다.
전역변수는 사용하지 않는 것이 좋고 여러가지 이유로 그 값이 변경될 여지가 많기 때문입니다.
예를 들어 함수 안에서 전역변수를 사용하고 있는데, 누군가에 의해서 전역변수의 값이 달라졌다면 어떻게 될까?

그 해당함수는 의도치 않은 결과로 인해 함수의 동작이 달라지게 되고 버그의 원인이 됩니다.
또한 함수를 다른 애플리케이션에 이식하는데도 어려움을 초래하게 됩니다. 
함수의 핵심은 로직의 재활용이라는 점을 기억하고, 변수를 선언할 때는 꼭 var를 붙이는 것을 습관화하도록 합시다.

var scope = 'global(전역변수)'; 
function fnScope() { 
	var scope = 'local(지역변수)'; 
	scope = 'local'; // 지역변수로 var scope가 이미 정의되었기 때문에 지역변수로 사용된다. 
} 
fnScope(); 
console.log(scope); // global;

DOM, BOM, javaScript
모든 객체들이 window라는 객체에 소속되어있다. 
동시에 전역객체라고도 한다.
dom > window.document
bom > window.navigator
JavaScript > window.Array

// 예를들면 다음 아래는 window라고 붙이든 안붙이든
// alert는 암시적으로 window를 생략한 것과 같다. 
// (alert는 경고창을 띄우는 역할을 한다.)

// 즉, 전역변수인 것이다.
// 전역함수라 함은 window라는 객체의 프로퍼티, 메소드를 만드는 것
alert('Hello world');
window.alert('Hello world');

var a = 1;        // a = 1 이라고 변수를 선언했을 때 접근하는 방법은
alert(a);        // a라고 해도되지만 window.a와도 같다.
alert(window.a);

var a = {id:1};
alert(a.id);
alert(window.a.id);

===========================================================================================================================


제이쿼리 라이브러리 창시자 -  존 레식(John Resig) https://ko.wikipedia.org/wiki/%EC%A1%B4_%EB%A0%88%EC%8B%9D
2006년에 첫 번째 버전을 배포


참조)https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript
배열의 length 속성은 최대 인덱스에 하나를 더한 값일 뿐입니다.

배열(Array)은 많은 데이터를 순번을 가지고 저장할 때 사용됩니다.
배열에는 원소라는 index 번호를 할당받은 저장소가 있으며, 배열의 원소에 index 로 접근하여 할당된 값을 읽어 올 수 있습니다.

많은 양의 데이터를 보관해야 할 때 배열을 사용하면 효율적으로 데이터를 관리할 수 있습니다.

하나의 변수에 여러 개의 데이터를 담을 수 있는 그릇 or 여러 개의 변수를 한꺼번에 다룰 수 있는 자료
대괄호[]를 사용해 생성하고 안에 쉼표로 구분해 자료를 입력
여러 개의 변수를 인덱스 번호로 관리

// #test1 Array() 생성자를 사용한 배열 생성
var arr = new Array();

예시)
var a = new Array();
a[0] = "dog";
a[1] = "cat";
a[2] = "hen";
a.length


// #test2 리터럴 형식으로 배열 생성
var arr = [];

예시)
var a = ["dog", "cat", "hen"];
a.length


// #test3 접근자를 사용한 데이터 할당
var arr = [];
for (i=0; i<1000; i++) {
	arr[i] = i;
};

// #test4 push() 메서드를 사용한 데이터 할당
var arr = [];
for (i=0; i<1000; i++) {
	arr.push(i);
}
결과를 보면 크롬을 제외한 대부분의 브라우저에서 
push() 메소드를 사용해 데이터를 할당하는 방법보다 
접근자 []를 사용해 데이터를 할당하는 코드의 실행 속도가 2배 정도 더 빠릅니다.


// #test5 리터럴을 사용한 오브젝트 객체 생성
var obj = {};

// #test6 생성자를 사용한 오브젝트 객체 생성
var obj = new Object();


// #test7 연산자를 이용한 데이터 삽입
var obj = {};
obj.a = 1;
obj.b = 2;
obj.c = 3;
obj.d = 4;
obj.e = 5;
obj.f = 6;
obj.g = 7;
obj.h = 8;
obj.i = 9;
obj.j = 10;

// #test8 [] 연산자를 이용한 데이터 삽입
var obj = {};
obj["a"] = 1;
obj["b"] = 2;
obj["c"] = 3;
obj["d"] = 4;
obj["e"] = 5;
obj["f"] = 6;
obj["g"] = 7;
obj["h"] = 8;
obj["i"] = 9;
obj["j"] = 10;




배열(array)
- 만약 어떤 변수에 여러개의 값을 지정하고 싶으면 배열을 사용한다..
- 배열이란 하나의 변수에 여러 개의 값을 순서에 따라 모아 놓은 것을 말함
- 배열 내의 각 값들을 배열 요소라고 부른다..
- 자바스크립트에서는 Array라는 지시자로 배열을 선언할 수 있다..
- 배열에 포함할 요소의 개수를 미리 지정할 수 있다.. (배열 요소의 개수를 미리 알 수 없는 경우 숫자 없이 선언해도 무방하다..)

var 변수 = Array(개수);
- 색인값(index)은 배열 요소의 순서와 위치를 알려준다..
- 인덱스는 대괄호[] 안에 표시한다..
- 결합형배열 (associative array) : 인덱스는 숫자 대신 문자열로 쓸 수도 있다.. (숫자를 쓰지 않아도 숫자형 배열이 자동으로 생성된다..)
- 첫 번째 인덱스는 0으로 지정된다..

array[index] = "배열요소값";


ex) 숫자형 배열

var dennis = Array(4);
dennis[0] = "가";
dennis[1] = "나";
dennis[2] = "다";
dennis[3] = "라";

- 배열을 좀 더 짧게 선언할 수 있다..
ex) 
var dennis = Array["가", "나", "다", "라"];

- 배열에 불린값이나 숫자를 지정해도 무방하다..
ex) 
var dennis = Array["가", 2012, "다", "라"];

- 배열 내의 배열 요소 값은 변수가 될 수 있다..
ex) 
var name = "가";
dennis[0] = name;

- 특정 배열 내의 배열 요소 값은 다른 배열의 요소가 될 수 있다..
ex) 
var name = Array["가", "나", "다", "라"];
dennis[1] = name[3];  

- 모든 배열 요소는 그 자체를 값으로 사용할 수 있다..
ex) 
var name = Array["가", "나", "다", "라"];
var dennis = Array();
dennis[0] = "나";


객체 배열
- 내장 객체 : 자바스크립트 안에 이미 정의되어 있는 객체
- 객체 배열 : 내장 객체 Array객체를 의미한다..

1) 객체 배열 생성

배열 이름 = new Array(개수);
배열 이름[index] = "배열요소값";

ex) 
dennis =  new Array(4);
dennis[0] = "가";
dennis[1] = "나";
dennis[2] = "다";
dennis[3] = "라";

- 객체를 만든 다음 한 번에 여러 값을 할당할 수 있다..
ex) 
dennis = new Array("가", "나", "다", "라");

- 대괄호를 이용하여 배열을 선언할 수 있다.. (괄호와 동일한 결과를 낸다..)
ex) 
dennis = new Array["가", "나", "다", "라"];


2) 배열 접근과 초기화

-  배열명과 첨자(개수)를 이용해서 접근한다..
   배열 이름[첨자]
ex) 
dennis[0] = 10;

- 선언과 동시에 초기화 할 수 있다..
배열 이름 = new Array(초기값, ...);
ex) 
dennis = new Array("가", "나", "다", "라");

배열 이름 = [초기값, ...];
ex) 
dennis = ["가", "나", "다", "라"];

3) Array 객체의 속성

-  length : 배열의 크기, 확보한 기억 공간의 개수
-  prototype : Array 객체에 새로운 속성을 추가 

4) Array 객체의 메소드

Array 객체를 이용한 반복문
ex)
dennis = new Array(5);
dennis[0] = "포토샵"
dennis[1] = "일러스트"
dennis[2] = "플래시"
dennis[3] = "드림위버"
dennis[4] = "자바스크립트"
for(var i=0; i<=4; i++){
	//document.write("[" + i + "] " + dennis[i] + "<br>");
	console.log("[" + i + "] " + dennis[i] + "<br>");
}

join(결합문자) 
- 배열 요소를 결합 문자로 연결한다..
- 결합 문자를 생략하면, 쉼표로 연결된다..
ex)
array1 = new Array("가", "나", "다");
document.write("<p>" + array1.join() + "<br>");
document.write(array1.join("&") + "</p>");
(출력)
가,나,다
가&나&다


sort()
- 배열 요소를 크기순으로 정렬한다..(문자열 오름차순 정렬)

reverse()
- 배열 요소를 거꾸로 바꾼다..
ex)
array1 = new Array("가", "나", "다");
array2 = new Array("A", "B", "C");
document.write(array1.sort() + "<br>");
document.write(array1.reverse() + "<br>");
document.write(array2.sort() + "<br>");
document.write(array2.reverse());
(출력)
가,나,다
다,나,가
A,B,C
B,C,A

ex) 매개 변수로 입력한 함수에 의한 정렬
(오름차순 정렬)
var array = [101, 102, 103, 104];
	array.sort(function (left, right) {
	return left - right;
});
alert(array);


concat(배열이름)
- 두 개의 배열을 하나로 합친다..
ex)
array1 = new Array("가", "나", "다");
array2 = new Array("A", "B", "C");
array3 = array1.concat(array2);
document.write(array3);
(출력)
가,나,다,A,B,C


slice(시작위치, 종료위치)
- 배열 요소 중 시작 위치에서부터 종료 위치 전까지를 분리해서 새로운 배열에 저장한다..
ex)
array1 = new Array("가", "나", "다","라");
array2 = array1.slice(1,3);
document.write(array2);

//배열요소 1번 시작위치의 "나"에서 종료위치 3번 "라"의 전까지 출력
(출력)
나,다


pop()
- 배열의 마지막 요소를 제거하고 리턴한다..

shift()는 맨 앞의 원소를 제거합니다.


push()
- 배열의 마지막 부분에 새로운 요소를 추가한다..

unshift()는 배열의 맨 앞에 원소를 추가합니다.

ex)
var jbAry1 = [ 'one', 'two', 'three' ];
jbAry1.push( 'four' );
document.write( '<p>' + jbAry1.join( ' / ' ) + '</p>' );
var jbAry2 = [ 'one', 'two', 'three' ];
jbAry2.pop();
document.write( '<p>' + jbAry2.join( ' / ' ) + '</p>' );
var jbAry3 = [ 'one', 'two', 'three' ];
jbAry3.unshift( 'zero' );
document.write( '<p>' + jbAry3.join( ' / ' ) + '</p>' );
var jbAry4 = [ 'one', 'two', 'three' ];
jbAry4.shift();
document.write( '<p>' + jbAry4.join( ' / ' ) + '</p>' );


splice()
- 배열 요소의 지정한 부분을 삭제하고 삭제한 요소를 리턴한다..
다시말하면 배열에서 특정 범위의 값들을 추출하고, 그 자리에 새로운 값을 넣습니다.

문법
array.splice( start, count )
예를 들어 
jbAry.splice( 1, 2 )는 jbAry  배열의 두번째 값부터 2개를 추출합니다.
array.splice( start, count, value1, value2, ... )
예를 들어 jbAry.splice( 1, 2, ‘abc’, ‘def’ )는 
jbAry  배열의 두번째 값부터 2개를 추출하고, 그 자리에 abc, def 두 값을 넣습니다.
추출한 값들은 새로운 배열로 반환합니다.
ex)
<!doctype html>
<html lang="ko">
<head>
	<meta charset="utf-8">
	<title>JavaScript</title>
</head>
<body>
	<p>jbAry : One,Two,Three,Four,Five,Six</p>
	<hr>
	<p><strong>var jbSplice = jbAry.splice( 2, 3 );</strong></p>
	<p>
		<script>
			var jbAry = [ 'One', 'Two', 'Three', 'Four', 'Five', 'Six' ];
			var jbSplice = jbAry.splice( 2, 3 );
			document.write( '<p>jbAry : ' + jbAry + '</p>' );
			document.write( '<p>jbSplice : ' + jbSplice + '</p>' );
		</script>
	</p>
	<p><strong>var jbSplice = jbAry.splice( 1, 2, 'Seven', 'Eight' );</strong></p>
	<p>
		<script>
			var jbAry = [ 'One', 'Two', 'Three', 'Four', 'Five', 'Six' ];
			var jbSplice = jbAry.splice( 1, 2, 'Seven', 'Eight' );
			document.write( '<p>jbAry : ' + jbAry + '</p>' );
			document.write( '<p>jbSplice : ' + jbSplice + '</p>' );
		</script>
	</p>
</body>
</html>




[함수]

======= 인자값(argument), 매개변수(parameter) ==================================================================================
함수를 선언하면서 () 안에 매개 변수를 설정할 수 있습니다.
선언된 함수의 () 안에 인자값을 넘겨 매개변수를 통해서 함수안의 구문에 값을 전달할 수 있습니다.
예시)
var a = 10; 
var b = 20; 
function add(v1, v2) { 
	var sum = v1 + v2; 
	return sum; 
} 
var sum = add(a, b); 
console.log(sum);

함수 add() 가 선언되었고, 함수 () 안에 매개변수 v1, v2 를 넘겨받습니다.
그리고 add() 함수를 호출하면서 변수 a, b 의 값을 인자값으로 넘겨줍니다.
함수가 호출되면 넘겨받은 인자의 값을 매개변수에서 받아서 처리하게 됩니다.
==============================================================================================================================


 ======= 반환값(return) ==================================================================================
함수가 호출되면 함수를 호출한 구문으로 값을 반대로 보내줄 수 있습니다.
그 역할을 해 주는 것이 반환(return)입니다.
반환값을 이용하면 프로그램을 유연하게 개발할 수 있습니다.
함수는 항상 값을 반환한다.
값을 반환하지 않고 단순히 코드만 실행하도록 함수를 만들 수도 있으나 함수가 값을 반환하는 것은 지극히 당연한 일이다.
함수 내부에서 반환할 값을 설정하지 않으면 undefined 가 반환된다.

==============================================================================================================================



함수 표현식
// 기명 함수표현식(named function expression) 
var company = function company() {
	/* 실행코드 */
}; 


// 익명 함수표현식(anonymous function expression)
var company = function() {
	/* 실행코드 */
};

// 기명 즉시실행함수(named immediately-invoked function expression)
(function company() {
	/* 실행코드 */
}());

// 익명 즉시실행함수(immediately-invoked function expression)
// Javascript 대가이신 더글라스 클락포트의 권장 표기법
(function() {
	/* 실행코드 */
}());

// 익명 즉시실행함수(immediately-invoked function expression)
(function() {
	/* 실행코드 */
})();

예시)
// 익명 함수표현식에 의한 명시적인 함수호출
var app = function() { 
	console.log('함수 호출'); // "함수 호출" 출력
};
app();

// 익명 즉시실행함수
(function() {
	console.log('함수 호출'); // "함수 호출" 출력
}());

//변수 선언후 출력
var app = (function() { 
	var privateVar = 'private';
	return {
		prop : privateVar
	};
}());
console.log(app.prop); // "private" 출력

var buyCar = function(carName) {  
	// "내가 구매한 차는 sonata입니다." 출력
	console.log('내가 구매한 차는 ' + carName + '입니다.');
};
buyCar('sonata');

(function(carName) {
	// "내가 구매한 차는 sonata입니다." 출력
	console.log('내가 구매한 차는 ' + carName + '입니다.');
}('sonata'));


jQuery나 Prototype 라이브러리는 동일한 $라는 글로벌 변수를 사용합니다. 
만약, 이 두개의 라이브러리를 같이 사용한다면 $ 변수에 대한 충돌이 생길 것입니다. 
하지만, 즉시실행함수의 코드 블럭에서 jQuery를 위한 $ 변수를 사용하고자 한다면 
아래와 같이 파라미터를 전달하는 방법으로 Prototype의 $ 변수에 대한 overwritting을 예방할 수 있습니다.
충돌방지위해 사용하는 제이쿼리 모듈화 방법
(function($) {
	// 함수 스코프 내에서 $는 jQuery Object임.
	console.log($);
}(jQuery));




자바스크립트로 선택하는 방법
//태그로 찾기
document.getElementsByTagName('div');
//클래스 이름으로 찾기
document.getElementsByClassName('class');
//id로 찾기 
document.getElementById('id');

//css 선택자의 문법을 이용해서 객체를 조회
// li 태그 중에서 첫번째만 가리킨다. 
var li = document.querySelector('li');
li.style.color='red';

// 해당 클래스이름을 가진 첫번째만 가리킨다.
var li = document.querySelector('.active');
li.style.color='blue';

// 첫번째만 가리키지 않고 모든 관련된 것을 가리킬 수도 있다.
var li = document.querySelectorAll('li');

getElementById : id
getElementsByName : name
getElementsByTagName : tag or '*'
getElementsByClassName : class
querySelector : CSS-selector
querySelectorAll : CSS-selector


/********* 자바스크립트 방법 *********/
function scriptClick(){
	document.getElementById("d1").innerHTML="안녕하세요";
}

/********* 제이쿼리 방법 *********/
$(document).ready(function(){
	$('#jqClick').click(function(){
		$("#d1").text("안녕하세요");
	})
});

<button id="jqClick">클릭하세요</button> <button onclick="scriptClick()">클릭하세요</button>
<section id="d1">
	<p>현재 자바스크립트를 공부하고 있습니다.</p>
</section>



참조) https://github.com/DeniceKim/FrontEndStudy/blob/master/document/Jquery/docs/01_00_jquery_%EA%B8%B0%EC%B4%88%EB%AC%B8%EC%84%9C.md

jQuery 란?

자바스크립트의 함수는 일련의 실행문을 함수 내에 정의했다가 필요할 때마다 호출하여 사용하는 것입니다.
제이쿼리는 이러한 다양한 함수들을 사용자에게 제공함으로써 
자바스크립트에서 몇 가지 불편하고 까다로웠던 점들을 더 간편하게 사용할 수 있도록 개선한 자바스크립트의 라이브러리입니다.


다음은 제이쿼리에서 개선된 사항들입니다.

호환성 문제점 해결
자바스크립트는 호환성(크로스브라우징)이 떨어지는데 이러한 호환성을 위해 
제이쿼리는 브라우저사마다 제각각 달리 구현되었던 사항들을 일관성있게 사용할 수 있도록 도와줍니다.

쉽고 편리한 애니메이션 효과 기능 구현
자바스크립트로 애니메이션 효과를 구현하려면 많은 코드를 사용해야 했고, 개발하는데도 많은 시간이 들었습니다.
하지만 제이쿼리는 애니메이션을 쉽게 구현할 수 있고, 다양한 효과(Effect)를 지원하는 메서드를 제공하고 있습니다.

보다 쉬운 탐색
jQuery Selector 는 CSS 의 selector 를 그대로 가져와서 반영해 줌으로서 CSS 문법이 익숙한 사용자가 손쉽게 사용할 수 있습니다.
CSS 를 접해보지 않더라도 손쉽게 빠르게 접근,사용할 수 있을 만큼 편리한 API입니다.

$(), jQuery(); jQuery 는 생성자 함수다. 
$() 팩토리(공장)함수 $() 는 내부적으로는 new JQuery() 를 init 하여 공장처럼 찍어낸다. 
돔객체를 던지면 제이쿼리 객체로 반환해준다. 
$() 는 함수를 호출하는 것이다. 
붕어빵 틀이 $() 짠 안에 인자를 넣으면 짠 하고 무언가 제이쿼리 객체가 나오지만 팩토리이기 때문에 계속 같은거를 던지지 말고 한번만 던져서 캐시, 
즉 참조해 놓는것이 같은 것을 만들어 내지 않는다. 
붕어빵 틀에서 붕어빵을 계속 찍어서 먹다보면 배가 부르겠죠?! 
그러면 브라우저도 배가 부르겠죠?! 
jQuery.fn 의 정체는 jQuery 팀이 $ 에 능력을 부여하여 만들었지만 그것을 사용자들에게 jQuery 기능을 확장하도록 가능하도록 해주는 것이 
$.fn 이다. 즉, jQuery 부모에 접근하여 모든 자식들이 상속받도록 하는 것이다.


$(document).ready(function(){ ... }); //페이지 로딩시 실행
$(function(){ ... }); 함수를 실행 하라는 의미
(function($){ ... })(jQuery); jquery를 사용할 때, $ 의 의미를 jquery에서 사용하겠다는 의미가 내포되어있다(제이쿼리 모듈화)
함수에서 $ 의미는 jquery 객체로 사용이 되는 것 


#제이쿼리 선택자
직접선택자
$("*")
$("tagname")
$("#name")
$(".name")
$("선택1, 선택2,...")

인접관계선택자
$("요소선택").parent() 한단계 위를 가리킴
$("요소선택").parents() 위에 있는거 전부를 가리킴
$("요소선택 하위요소") 공백 디센던트
$("요소선택>자식요소")
$("요소선택").children() 모든 자식요소
$("요소선택").prev() 선택요소의 이전
$("요소선택").prevAll()
$("요소선택").prevUntil("요소명") 선택한것부터 선택한것까지 
$("요소선택").next() 선택요소의 다음 $("요소선택+다음요소") 
$("요소선택").nextAll()
$("요소선택").nextUntil("요소명") 선택한것부터 선택한것까지 
$("요소선택").siblings() 나는 제외 형제만

#제이쿼리 탐색 선택자
-위치 탐색 선택자
$("요소선택:first") *
$("요소선택").first()
ex) $("li:first") $("li"),first() - 전제 li 요소 중에서 첫번째

$("요소선택:last") *
$("요소선택").last()

$("요소선택:odd") 영부터 시작함 홀수
$("요소선택:even") 짝수

$("요소선택:first-of-type")
$("요소선택:last-of-type")

$("요소선택:nth-child(숫자)") *
$("요소선택:nth-child(숫자n)")
$("요소선택:nth-of-type(숫자)")

$("요소선택:only-child") 자식이 하나인 요소만 선택
$("요소선택:eq(index)") index에 참조하는 요소 *
$("요소선택").eq(index)
$("요소선택:gt(index)") index보다 큰 index가 참조하는 요소 *
$("요소선택:lt(index)") index보다 작은 index가 참조하는 요소
$("요소선택").slice(index) index부터 참조하는 요소 *

#속성 탐색 선택자
$("요소선택[속성]")   ex)("li[title]")
$("요소선택[속성=값]")

$("요소선택[속성^=값]")
$("요소선택[속성$=값]")
$("요소선택[속성]*=값")

$("요소선택:hidden")
$("요소선택:visible")
$("요소선택:text") -<input> 요소 중 type이 text인 요소만 선택
$("요소선택:selected")
$("요소선택:checked)

-->
</body>
</html>
    /**
 * jCarouselLite - jQuery plugin to navigate images/any content in a carousel style widget.
 * @requires jQuery v1.2 or above
 *
 * http://gmarwaha.com/jquery/jcarousellite/
 *
 * Copyright (c) 2007 Ganeshji Marwaha (gmarwaha.com)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Version: 1.0.1
 * Note: Requires jquery 1.2 or above from version 1.0.1

 * customize:
 *  - li elements width '%' unit edit
 *  - pagination, current page class add
 *  - auto circular botton add
 */

var jCarouselLiteStart,
	jCarouselLiteStop;


(function($) {
                                          // Compliant with jquery.noConflict()
$.fn.jCarouselLite = function(o) {
    o = $.extend({
        btnPrev : null,
        btnNext : null,
        btnGo : null,
        btnAuto : null,

        mouseWheel: false,
        auto: null,

		/* add autoPlay control */
		automatic : true,

        speed: 200,
        easing: null,

        vertical: false,
        circular: true,
        visible: 3,
        start: 0,
        scroll: 1,

        beforeStart: null,
        afterEnd: null
    }, o || {});

    return this.each(function() {                           // Returns the element collection. Chainable.

        var running = false, animCss=o.vertical?"top":"left", sizeCss=o.vertical?"height":"width";
        var div = $(this), ul = $("ul", div), tLi = $("li", ul), tl = tLi.size(), v = o.visible;

        if(o.circular) {
            ul.prepend(tLi.slice(tl-v-1+1).clone())
              .append(tLi.slice(0,v).clone());
            o.start += v;
        }

        var li = $("li", ul), itemLength = li.size(), curr = o.start;
        div.css("visibility", "visible");

        li.css({overflow: "hidden", float: o.vertical ? "none" : "left"});
        ul.css({margin: "0", padding: "0", position: "relative", "list-style-type": "none", "z-index": "1"});
        div.css({overflow: "hidden", position: "relative", "z-index": "2", left: "0", height: "100%"});

        var liSize = 100;   // Full li size(incl margin)-Used for animation
        var ulSize = liSize * itemLength;                   // size of full ul(total length, not just for the visible items)
        var divSize = liSize * v;                           // size of entire div(total length for just the visible items)
        var liReSize = liSize / itemLength;

        var currentNum = 0;

        var autoPlay;
        var autoStop;




        li.css({width: liReSize+'%'});
        ul.css(sizeCss, ulSize+"%").css(animCss, -(curr*liSize)+"%");
        div.css(sizeCss, divSize+"%");                     // Width of the DIV. length of visible images

        // current class Add & Remove
        function crrentClass() {
            for ( i = 0; i <= o.btnGo.length; i++ ) {
                if (currentNum == i) {
                    $(o.btnGo[i]).addClass(o.pageCurrent);
                } else {
                    $(o.btnGo[i]).removeClass(o.pageCurrent);
                }
            }
        }

        // auto circular
        var autoCircular = function() {
            if (autoPlay == true) {
                autoInterval = setInterval(function() {
                    go(curr+o.scroll, 'next');
                }, o.auto+o.speed);

            } else if (autoPlay == false) {
                clearInterval(autoInterval);
            }
        };

        // touch swipe - jquery.touchswipe.js
        try {
            ul.swipe({
                swipeStatus:function(event, phase, direction, distance, duration, fingerCount) {
                    if( phase=="end" && (direction=="left" || direction=="right") ) {
                        if (direction == "left" ) {

                            setTimeout(function () {
                                return go(curr+o.scroll, 'next');
                            }, 50);

                        }
                        else if (direction == "right") {

                            setTimeout(function () {
                                return go(curr-o.scroll, 'prev');
                            }, 50);

                        }
                    }
                },
                allowPageScroll:"vertical",
                threshold:50
            });
        } catch (e) {

        }

        if(o.btnPrev)
            $(o.btnPrev).click(function() {
                return go(curr-o.scroll, 'prev');
            });

        if(o.btnNext)
            $(o.btnNext).click(function() {
                return go(curr+o.scroll, 'next');
            });

        if(o.btnGo)
            $.each(o.btnGo, function(i, val) {
                $(val).click(function() {
                    currentNum = i;
                    return go(o.circular ? o.visible+i : i);
                });
            });

        if(o.mouseWheel && div.mousewheel)
            div.mousewheel(function(e, d) {
                return d>0 ? go(curr-o.scroll) : go(curr+o.scroll);
            });


		 if(o.auto) {
			setTimeout(function() { // safari roop bugfix
				autoPlay = true;
				autoStop = false;
				autoCircular();
			}, 10);
		}


		/* add autoPlay control */
		if( o.automatic == 0 ){
			setTimeout(function() { // safari roop bugfix
				autoPlay = false;
				autoStop = true;
				autoCircular();
				$(o.btnAuto).addClass('autoplay');

			}, 10);
		}


        if(o.btnAuto)
            $(o.btnAuto).click(function() {
                if (autoPlay == true) {
                    autoPlay = false;
                    autoStop = true;
                    // console.log('autoStop: '+ autoStop);
                    autoCircular();
                    $(o.btnAuto + ' span').html('Play');
                    $(this).addClass('autoplay');
                    //omni_call('content_click','home:kv rolling:stop');
                } else if (autoPlay == false){
                    autoPlay = true;
                    autoStop = false;
                    // console.log('autoStop: '+ autoStop);
                    autoCircular();
                    $(o.btnAuto + ' span').html('Pause');
                    $(this).removeClass('autoplay');
                    //omni_call('content_click','home:kv rolling:play');
                }
            });

        /* swipe scroll */


		// slide start/stop api ADD
		jCarouselLiteStart = function(){
			console.log("start")
			autoPlay = true;
			autoStop = false;
			autoCircular();
		}

		jCarouselLiteStop = function(){
			console.log("stop")
			autoPlay = false;
			autoStop = true;
			autoCircular();
		}

        function vis() {
            return li.slice(curr).slice(0,v);
        };

        function go(to, estatus) {
            if(!running) {
                if(o.beforeStart)
                    o.beforeStart.call(this, vis());

                // auto Circular reset
                if(o.auto && autoStop == false) {
                    autoPlay = false;
                    autoCircular();
                    // console.log('auto reset');
                }

                if(estatus == 'next')
                    currentNum++;
                    currentNum = currentNum % o.btnGo.length;

                if(estatus == 'prev')
                    currentNum--;
                    currentNum = (o.btnGo.length + currentNum) % o.btnGo.length;

                // pagenation button class add
                crrentClass();

                if(o.circular) {            // If circular we are in first or last, then goto the other end
                    if(to<=o.start-v-1) {           // If first, then goto last
                        ul.css(animCss, -((itemLength-(v*2))*liSize)+"%");
                        // If "scroll" > 1, then the "to" might not be equal to the condition; it can be lesser depending on the number of elements.
                        curr = to==o.start-v-1 ? itemLength-(v*2)-1 : itemLength-(v*2)-o.scroll;
                    } else if(to>=itemLength-v+1) { // If last, then goto first
                        ul.css(animCss, -( (v) * liSize ) + "%" );
                        // If "scroll" > 1, then the "to" might not be equal to the condition; it can be greater depending on the number of elements.
                        curr = to==itemLength-v+1 ? v+1 : v+o.scroll;
                    } else curr = to;
                } else {                    // If non-circular and to points to first or last, we just return.
                    if(to<0 || to>itemLength-v) return;
                    else curr = to;
                }                           // If neither overrides it, the curr will still be "to" and we can proceed.

                running = true;

                ul.animate(
                    animCss == "left" ? { left: -(curr*liSize)+'%' } : { top: -(curr*liSize)+'%'} , o.speed, o.easing,
                    function() {
                        if(o.afterEnd)
                            o.afterEnd.call(this, vis());
                        running = false;
                    }
                );
                // Disable buttons when the carousel reaches the last/first, and enable when not
                if(!o.circular) {
                    $(o.btnPrev + "," + o.btnNext).removeClass("disabled");
                    $( (curr-o.scroll<0 && o.btnPrev)
                        ||
                       (curr+o.scroll > itemLength-v && o.btnNext)
                        ||
                       []
                     ).addClass("disabled");
                }

                // auto Circular init
                    if(o.auto && autoStop == false) {
                        autoPlay = true;
                        autoCircular();
                        // console.log('auto init');
                    }
            }
            return false;
        };
    });
};

function css(el, prop) {
    return parseInt($.css(el[0], prop)) || 0;
};
function width(el) {
    return  el[0].offsetWidth + css(el, 'marginLeft') + css(el, 'marginRight');
};
function height(el) {
    return el[0].offsetHeight + css(el, 'marginTop') + css(el, 'marginBottom');
};



})(jQuery);